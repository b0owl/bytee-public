#!/usr/bin/env python3
"""
Generate dist/bytee.h — a stb-style single-header amalgam of the bytee engine.

Usage:
    python3 tools/amalgamate.py [project_root]

The generated file lets users include the entire engine by:
    - Putting #define BYTEE_IMPLEMENTATION in exactly ONE .cpp before including it.
    - Including it normally everywhere else.
"""

import os, re, sys

ROOT = sys.argv[1] if len(sys.argv) > 1 else os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
INC  = os.path.join(ROOT, 'engine', 'include')
SRC  = os.path.join(ROOT, 'engine', 'src')
VND  = os.path.join(ROOT, 'engine', 'vendor')
DIST = os.path.join(ROOT, 'dist')
os.makedirs(DIST, exist_ok=True)


def read_file(path):
    with open(path, 'r', encoding='utf-8', errors='replace') as f:
        return f.read()


# Basenames of headers / vendor files that we're inlining — strip these includes.
STRIP_BASENAMES = {
    'bytee.h', 'allocator.h', 'rendering.h', 'window.h',
    'keyboard.h', 'mouse.h', 'collisions.h',
    'stb_image.h', 'stb_truetype.h',
    'scene.h', 'scene_manager.h',
}


def strip_internal_includes(src):
    """Remove #include lines for headers being inlined, and STB impl defines."""
    result = []
    for line in src.splitlines():
        stripped = line.strip()
        # Strip internal includes
        if stripped.startswith('#include'):
            m = re.search(r'#\s*include\s*[<"](.*?)[>"]', stripped)
            if m and os.path.basename(m.group(1)) in STRIP_BASENAMES:
                continue
        # Strip STB_*_IMPLEMENTATION defines (we write our own)
        if re.match(r'\s*#\s*define\s+STB_\w+_IMPLEMENTATION\b', stripped):
            continue
        result.append(line)
    return '\n'.join(result)


def strip_header_guard(src):
    """
    Remove the outermost include guard (#ifndef / #define / trailing #endif)
    and any #pragma once directives.
    """
    lines = src.splitlines()
    result = []
    guard_skipped = False
    skip_next_define = False

    for line in lines:
        stripped = line.strip()
        if stripped == '#pragma once':
            continue
        if not guard_skipped and re.match(r'#\s*ifndef\s+\w+', stripped):
            guard_skipped = True
            skip_next_define = True
            continue
        if skip_next_define and re.match(r'#\s*define\s+\w+', stripped):
            skip_next_define = False
            continue
        result.append(line)

    # Remove the very last #endif (closing the guard).
    for i in range(len(result) - 1, -1, -1):
        if result[i].strip().startswith('#endif'):
            result.pop(i)
            break

    return '\n'.join(result)


def section(name):
    bar = '=' * 60
    return f'\n// {bar}\n// {name}\n// {bar}\n'


# ── Assemble output ──────────────────────────────────────────────────────────

out = []

out.append("""\
// ================================================================
//  bytee.h  —  single-header amalgam of the bytee engine
//  Generated by tools/amalgamate.py  —  do not edit manually
// ================================================================
//
// USAGE:
//   In exactly ONE .cpp file, before including this header:
//       #define BYTEE_IMPLEMENTATION
//       #include "bytee.h"
//
//   In all other files:
//       #include "bytee.h"
//
// EXTERNAL DEPENDENCIES (must be on your include/link path):
//   GLFW3, OpenGL, freetype2
//
// ================================================================

#ifndef BYTEE_SINGLE_H
#define BYTEE_SINGLE_H

// Platform GL
#ifdef __APPLE__
  #include <OpenGL/gl.h>
#else
  #include <GL/gl.h>
#endif
#include <GLFW/glfw3.h>

// Standard library used by the public API
#include <array>
#include <vector>
#include <string>
#include <cstdlib>
#include <memory>
""")

# ── Public API headers ────────────────────────────────────────────────────────

# keyboard.h: has a KEYBOARD_IMPL split — keep only the extern/declaration half.
keyboard_raw = read_file(os.path.join(INC, 'keyboard.h'))
keyboard_decl = re.sub(r'#ifdef KEYBOARD_IMPL.*?#else\s*(.*?)\s*#endif', r'\1', keyboard_raw, flags=re.DOTALL)
keyboard_decl = strip_internal_includes(keyboard_decl)
keyboard_decl = strip_header_guard(keyboard_decl)

# The implementation block from keyboard.h (storage definitions).
m = re.search(r'#ifdef KEYBOARD_IMPL\s*(.*?)\s*#else', keyboard_raw, re.DOTALL)
keyboard_impl = m.group(1).strip() if m else ''

for name, content in [
    ('KEYBOARD',   keyboard_decl),
    ('MOUSE',      strip_header_guard(strip_internal_includes(read_file(os.path.join(INC, 'mouse.h'))))),
    ('ALLOCATOR',  strip_header_guard(strip_internal_includes(read_file(os.path.join(INC, 'allocator.h'))))),
    ('RENDERING',  strip_header_guard(strip_internal_includes(read_file(os.path.join(INC, 'rendering.h'))))),
    ('COLLISIONS',    strip_header_guard(strip_internal_includes(read_file(os.path.join(INC, 'collisions.h'))))),
    ('WINDOW',        strip_header_guard(strip_internal_includes(read_file(os.path.join(INC, 'window.h'))))),
    ('SCENE',         strip_header_guard(strip_internal_includes(read_file(os.path.join(SRC, 'scene_manager', 'scene.h'))))),
    ('SCENE_MANAGER', strip_header_guard(strip_internal_includes(read_file(os.path.join(SRC, 'scene_manager', 'scene_manager.h'))))),
]:
    out.append(section(name))
    out.append(content.strip())
    out.append('\n')


# ── Implementation block ──────────────────────────────────────────────────────

out.append('\n#ifdef BYTEE_IMPLEMENTATION\n')

# keyboard storage definitions
if keyboard_impl:
    out.append(section('KEYBOARD — storage definitions'))
    out.append(keyboard_impl)
    out.append('\n')

# stb vendor headers (inline their full content, guarded by their own macros)
for impl_define, vendor_file in [
    ('STB_IMAGE_IMPLEMENTATION',    'stb_image.h'),
    ('STB_TRUETYPE_IMPLEMENTATION',  'stb_truetype.h'),
]:
    out.append(section(f'VENDOR: {vendor_file}'))
    out.append(f'#define {impl_define}\n')
    out.append(read_file(os.path.join(VND, vendor_file)))
    out.append('\n')

# Engine source files
for src_file in ['allocator.cpp', 'rendering.cpp', 'window.cpp', 'scene_manager/scene_manager.cpp']:
    src = read_file(os.path.join(SRC, src_file))
    src = strip_internal_includes(src)
    out.append(section(f'{src_file.upper()} — implementation'))
    out.append(src.strip())
    out.append('\n')

out.append('\n#endif // BYTEE_IMPLEMENTATION\n')
out.append('\n#endif // BYTEE_SINGLE_H\n')


output_path = os.path.join(DIST, 'bytee.h')
with open(output_path, 'w', encoding='utf-8') as f:
    f.write('\n'.join(out))

size_kb = os.path.getsize(output_path) // 1024
print(f'Generated {os.path.relpath(output_path, ROOT)}  ({size_kb} KB)')
